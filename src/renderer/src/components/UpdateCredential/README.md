# UpdateCredential 组件逻辑说明书

## 1. 字段禁用逻辑

### 简单描述
决定某个字段是否可以编辑，主要看当前是否在继承模式

### 详细规则
1. 如果是断开继承状态：所有字段都能编辑（优先级最高）
2. 如果不是继承模式：所有字段都能编辑
3. 如果是继承模式：
   - 看这个字段在基础凭据里有没有
   - 如果基础凭据没有这个字段：能编辑
   - 如果基础凭据也有这个字段：看当前凭据配置里的override属性
     - override为true：能编辑（允许覆盖）
     - override为false：通常不能编辑（强制继承）
     - 特殊情况：非密码字段如果没有值，即使override为false也允许编辑（防止无法输入值）

### 判断状态的方法
- 断开继承状态：isBrokenInheritance为true
- 继承模式：isCopiedData为true 或者 formData.base有值

## 2. 保存数据逻辑

### 三种保存模式

#### 模式1：断开继承模式
- 触发条件：用户刚刚断开了继承关系
- 保存内容：
  - base字段设为空字符串（表示不再继承）
  - 所有普通字段都发送到服务器，没有值时优先发送默认值
  - 密码字段只发送用户重新输入的，掩码不发送

#### 模式2：继承模式
- 触发条件：用户选择了继承某个凭据
- 保存内容：
  - base字段设为被继承凭据的名称
  - 只发送允许修改且确实被修改的字段
  - 判断允许修改：字段必须有override权限或者是当前凭据独有的
  - 判断确实修改：和继承时的初始值比较
  - 特殊处理：当前凭据独有的字段如果没有值但有默认值，传递默认值

#### 模式3：普通编辑模式
- 触发条件：正常编辑，没有继承关系
- 保存内容：
  - 和加载时的初始值比较，只发送有变化的字段
  - 密码字段特殊处理：如果不是掩码就发送
  - 特殊处理：字段没有值但有默认值时，也发送默认值

### 通用规则
- 只有真的有修改才调用API
- 密码字段的掩码"••••••••"永远不发送到服务器
- 保存成功后通知父组件更新页面显示

## 3. 继承配置逻辑

### 触发时机
用户在用户名字段点击"继承配置"下拉菜单，选择某个凭据

### 执行过程
1. 设置状态：标记当前进入继承模式，清除断开继承状态
2. 设置base字段：记录被继承凭据的名称
3. 复制字段值（只继承base凭据有配置的字段）：
   - 检查源凭据是否有该字段配置
   - 如果源凭据有该字段配置：
     - 密码字段：统一显示掩码，清除重置标记（切换回正常密码框）
     - 普通字段：按优先级取值
       - 优先1：被继承凭据的实际值
       - 优先2：被继承凭据配置的默认值
       - 无值时：保持当前字段值不变
   - 如果源凭据没有该字段配置：保持当前字段值不变（不清空）
4. 保存快照：记录继承后的状态作为初始值，用于后续检测修改

### 继承后的限制
- 被继承的密码字段变为只读显示掩码
- 被继承的其他字段根据override属性决定是否可编辑
- 当前凭据独有的字段保持可编辑状态

## 4. 断开继承逻辑

### 触发时机
用户在继承状态下点击"断开继承"按钮

### 确认过程
弹出警告对话框，告知用户后果：
- 凭据将变为独立维护
- 不再自动同步基础凭据的变更
- 密码字段将被清空需要重新设置

### 执行过程
1. 获取当前基础凭据的数据
2. 填充表单：
   - 密码字段：清空，标记需要重新输入
   - 基础凭据存在的普通字段：复制基础凭据的值或使用默认值
   - 当前凭据独有的字段：保持原值不变（不清空）
3. 清除继承关系：base字段清空
4. 更新状态：标记为断开继承模式
5. 保存新的初始值快照

### 断开后的状态
- 所有字段变为可编辑
- 密码字段显示为新密码输入框（绿色边框）
- 保存时会发送所有字段数据

## 5. 密码字段特殊处理

### 显示逻辑
- 初始状态：显示掩码"••••••••"
- 聚焦时：如果是掩码则清空，允许输入
- 失焦时：如果为空则恢复掩码显示

### 两种密码输入框
- 普通密码框：正常的密码字段，有聚焦失焦处理
- 新密码框：断开继承后显示，绿色边框，直接允许输入

### 验证规则
- 如果是掩码："••••••••"，跳过验证（表示密码未修改）
- 如果是实际输入：按正常密码规则验证（必填、长度等）

### 状态管理
每个密码字段都有独立的状态：
- focused：是否聚焦
- showPassword：是否显示密码内容
- needReset：是否需要重新输入（断开继承时使用）

## 6. 数据加载逻辑

### 触发时机
- 对话框打开时
- 切换编辑的凭据时
- 凭据列表更新时

### 加载过程
1. 清空所有表单数据和状态
2. 重置所有标记位（继承状态、断开状态等）
3. 初始化密码字段状态
4. 根据凭据配置填充表单：
   - 密码字段：统一显示掩码，重置标记设为false（使用正常密码框）
   - 普通字段：使用实际值或默认值
5. 保存初始状态快照用于后续变更检测

## 7. 表单验证逻辑

### 动态生成规则
根据字段配置自动生成验证规则，不是写死的

### 验证类型
- 必填验证：required为true的字段
- 密码验证：seal为true的字段，有特殊的掩码处理
- 服务器地址验证：fieldName为server的字段，用正则表达式
- 邮箱验证：fieldName为email的字段

### 密码验证特殊处理
- 如果是掩码则跳过验证
- 如果是实际输入则按密码规则验证
- 避免掩码状态下的误报错误

## 8. 可继承凭据列表逻辑

### 过滤规则
从所有凭据中筛选出可以被继承的：
1. 排除自己（不能继承自己）
2. 排除已经继承了自己的（防止循环继承）
3. 排除已经有继承关系的凭据（base字段有值，只允许独立凭据被继承）
4. 排除没有共同字段的凭据（没有共同字段就没有继承意义）

### 为什么这样设计
- 防止循环继承和复杂的继承链
- 只允许独立凭据作为基础凭据，避免多层继承带来的复杂性
- 只显示有意义的继承选项，提升用户体验

## 9. 状态重置逻辑

### 重置时机
- 对话框关闭时
- 组件卸载时

### 重置内容
- 清空所有表单数据
- 清空所有密码字段状态
- 清空所有重置标记
- 重置所有状态标记位
- 重置表单验证状态

### 为什么要彻底重置
确保下次打开时是干净的状态，避免残留数据影响

## 10. 模板渲染逻辑

### 字段类型判断
根据字段名和配置决定显示什么组件：
- fieldName是username：显示带继承功能的用户名字段
- fieldConfig.seal是true：显示密码字段
- fieldName是server：显示服务器字段
- 其他：显示普通文本字段

### 继承状态显示
在用户名字段根据是否有base值决定显示：
- 有base值：显示继承状态标签和断开继承按钮
- 没有base值：显示继承配置下拉菜单

### 密码字段选择
根据是否需要重置决定显示：
- 需要重置：显示新密码输入框（绿色样式）
- 不需要重置：显示普通密码框（有聚焦失焦处理）

## 11. 组件事件说明

### 对外暴露的事件

#### update:visible
- **触发时机**：对话框关闭时
- **传递参数**：boolean - 对话框的显示状态
- **用途**：通知父组件更新对话框的显示状态，实现双向绑定

#### saved
- **触发时机**：保存操作成功完成后
- **传递参数**：object - 保存后的凭据数据
- **用途**：通知父组件凭据已保存成功，用于更新父组件的凭据列表显示

### 事件触发顺序
1. 用户点击保存按钮
2. 表单验证通过
3. API调用成功
4. 触发 saved 事件
5. 触发 update:visible 事件关闭对话框

### 使用场景
- saved事件：主要用于更新页面上的凭据列表数据
- update:visible事件：用于控制对话框的显示和隐藏

## 总结

这些逻辑交织在一起形成了当前组件的复杂性，核心问题是状态管理分散、逻辑判断复杂、职责不清晰。 